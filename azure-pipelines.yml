trigger:
- main

pool:
  vmImage: 'ubuntu-latest'

variables:
  node_version: '20.x'
  python_version: '3.12'
  azureConnection: 'azure-tp05-connection'

  # Nombres de las Web Apps (las tomás de variables de UI)
  apiQaName:   '$(apiAppNameQA)'
  apiProdName: '$(apiAppNamePROD)'
  webQaName:   '$(webAppNameQA)'
  webProdName: '$(webAppNamePROD)'

  # Toggle de pruebas de humo
  runSmokeTests: 'false'   # poné 'true' si querés ejecutarlas

stages:
# ==================== BUILD & ANALYZE ====================
- stage: Build
  displayName: Build, Test, Coverage & Sonar
  jobs:
  - job: build_and_analyze
    displayName: Front + Back + Coverage + Sonar
    steps:
    - checkout: self
      fetchDepth: 0

    # ---------- Node + Python toolchains ----------
    - task: NodeTool@0
      inputs:
        versionSpec: '$(node_version)'

    - task: UsePythonVersion@0
      inputs:
        versionSpec: '$(python_version)'
        architecture: 'x64'

    # ---------- SonarCloud: Prepare (usa sonar-project.properties) ----------
    - task: SonarCloudPrepare@3
      displayName: 'Prepare SonarCloud analysis'
      inputs:
        SonarCloud: 'SonarCloud'             # nombre de tu Service Connection
        organization: 'chinogandara'         # org de SonarCloud
        scannerMode: 'cli'
        cliScannerVersion: '6.2.1.4610'      # la que ya está usando el log
        configMode: 'file'
        configFile: 'sonar-project.properties'
        extraProperties: |
          sonar.projectBaseDir=$(System.DefaultWorkingDirectory)

          sonar.python.coverage.reportPaths=backend/coverage.xml

          sonar.javascript.lcov.reportPaths=frontend/coverage/lcov.info

          sonar.exclusions=**/node_modules/**,**/dist/**,frontend/cypress/**,**/*.spec.ts

          sonar.javascript.file.suffixes=.js
          sonar.typescript.file.suffixes=.ts,.tsx,.cts,.mts

    # ---------- SonarCloud: Run analysis & publish Quality Gate ----------
    - task: SonarCloudAnalyze@3
      displayName: 'Run SonarCloud analysis'
      inputs:
        jdkversion: 'JAVA_HOME_17_X64'

    - task: SonarCloudPublish@3
      displayName: 'Publish SonarCloud quality gate'
      inputs:
        pollingTimeoutSec: '300'


    # ---------- FRONTEND: install + unit tests (coverage) ----------
    - script: |
        set -e
        cd frontend
        npm ci --no-audit --no-fund || npm i --no-audit --no-fund --legacy-peer-deps
      displayName: 'Frontend - npm ci'

    - script: |
        set -e
        cd frontend
        npm run test:ci
      displayName: 'Frontend - unit tests with coverage'

    - script: |
        set -e
        cd frontend
        npm run e2e
      displayName: 'Frontend - Cypress E2E'


    # ---------- FRONTEND: build prod + package artifact ----------
    - script: |
        set -e
        cd frontend
        npm run build:prod
      displayName: 'Frontend - ng build --configuration=production'

    - task: ArchiveFiles@2
      displayName: 'Package frontend dist as ZIP'
      inputs:
        rootFolderOrFile: 'frontend/dist'
        includeRootFolder: false
        archiveFile: '$(Build.ArtifactStagingDirectory)/front.zip'
        archiveType: 'zip'

    # ---------- BACKEND: deps + lint + tests (coverage + integración) ----------
    - script: |
        set -e
        cd backend
        python -m pip install --upgrade pip
        pip install -r requirements.txt
      displayName: 'Backend - install deps'

    - script: |
        set -e
        cd backend
        flake8 app
      displayName: 'Backend - flake8'

    - script: |
        set -e
        cd backend
        pytest --junitxml=TEST-backend.xml
      displayName: 'Backend - pytest (unit + integration + coverage)'

    - task: PublishTestResults@2
      displayName: 'Publish backend unit test results'
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: 'backend/TEST-backend.xml'
        failTaskOnFailedTests: true

    - task: ArchiveFiles@2
      displayName: 'Package backend as ZIP'
      inputs:
        rootFolderOrFile: 'backend'
        includeRootFolder: true
        archiveFile: '$(Build.ArtifactStagingDirectory)/backend.zip'
        archiveType: 'zip'

    - task: PublishBuildArtifacts@1
      displayName: 'Publish frontend artifact'
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)/front.zip'
        artifactName: 'front'
        publishLocation: 'Container'

    - task: PublishBuildArtifacts@1
      displayName: 'Publish backend artifact'
      inputs:
        pathToPublish: '$(Build.ArtifactStagingDirectory)/backend.zip'
        artifactName: 'back'
        publishLocation: 'Container'

    # ---------- SonarCloud: Run analysis & publish Quality Gate ----------
    - task: SonarCloudAnalyze@2
      displayName: 'Run SonarCloud analysis'

    - task: SonarCloudPublish@2
      displayName: 'Publish SonarCloud quality gate'
      inputs:
        pollingTimeoutSec: '300'

# ==================== DEPLOY QA ====================
- stage: DeployQA
  displayName: Deploy to QA
  dependsOn: Build
  condition: succeeded()
  jobs:
  - deployment: QaDeploy
    displayName: Deploy Front & API to QA
    environment: 'QA'    # usá el Environment de Azure con aprobaciones configuradas
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: front
          - download: current
            artifact: back

          # Genero env.js QA
          - script: |
              set -e
              echo "window.__env = { apiBase: '$(apiBaseUrlQA)' };" > "$(Pipeline.Workspace)/env.qa.js"
            displayName: 'Generate env.js (QA)'

          # Re empaqueto el front + env.js QA
          - script: |
              set -e
              mkdir -p "$(Pipeline.Workspace)/front_qa_unpack"
              cd "$(Pipeline.Workspace)/front_qa_unpack"
              unzip -q "$(Pipeline.Workspace)/front/front.zip"
              mkdir -p assets
              cp "$(Pipeline.Workspace)/env.qa.js" assets/env.js
              # acá el zip se crea en el cwd (front_qa_unpack)
              zip -qr "front-qa-with-env.zip" .
            displayName: 'Repackage front with env.js (QA)'

          # Deploy FRONT QA
          - task: AzureWebApp@1
            displayName: 'Deploy FRONT to $(webQaName)'
            inputs:
              azureSubscription: '$(azureConnection)'
              appType: 'webAppLinux'
              appName: '$(webQaName)'
              package: '$(Pipeline.Workspace)/front_qa_unpack/front-qa-with-env.zip'

          # Deploy API QA
          - task: AzureWebApp@1
            displayName: 'Deploy API to $(apiQaName)'
            inputs:
              azureSubscription: '$(azureConnection)'
              appType: 'webAppLinux'
              appName: '$(apiQaName)'
              package: '$(Pipeline.Workspace)/back/backend.zip'

          # Seed QA (opcional)
          - script: |
              set -e
              echo "Seeding QA..."
              curl -X POST "$(apiBaseUrlQA)admin/seed" -H "X-Seed-Token: $(seedTokenQA)"
            displayName: 'Seed QA DB'
            condition: and(succeeded(), ne(variables['seedTokenQA'], ''))

          # Smoke tests QA (API + FRONT)
          - script: |
              set -e
              echo "Waiting API to be ready..."
              for i in {1..20}; do
                curl -fsS "$(apiBaseUrlQA)readyz" && break || sleep 5
              done
              curl -fsS "$(apiBaseUrlQA)healthz"
              echo "Checking FRONT (index)..."
              for i in {1..20}; do
                curl -fsS "$(webBaseUrlQA)" && break || sleep 5
              done
            displayName: 'Smoke tests QA'
            condition: and(succeeded(), eq(variables['runSmokeTests'], 'true'))

# ==================== DEPLOY PROD ====================
- stage: DeployPROD
  displayName: Deploy to PROD
  dependsOn: DeployQA
  condition: succeeded()
  jobs:
  - deployment: ProdDeploy
    displayName: Deploy Front & API to PROD
    environment: 'PROD'   # acá configurás aprobación manual
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: front
          - download: current
            artifact: back

          # Genero env.js PROD
          - script: |
              set -e
              echo "window.__env = { apiBase: '$(apiBaseUrlPROD)' };" > "$(Pipeline.Workspace)/env.prod.js"
            displayName: 'Generate env.js (PROD)'

          # Re empaqueto el front + env.js PROD
          - script: |
              set -e
              mkdir -p "$(Pipeline.Workspace)/front_prod_unpack"
              cd "$(Pipeline.Workspace)/front_prod_unpack"
              unzip -q "$(Pipeline.Workspace)/front/front.zip"
              mkdir -p assets
              cp "$(Pipeline.Workspace)/env.prod.js" assets/env.js
              zip -qr "front-prod-with-env.zip" .
            displayName: 'Repackage front with env.js (PROD)'

          # Deploy FRONT PROD
          - task: AzureWebApp@1
            displayName: 'Deploy FRONT to $(webProdName)'
            inputs:
              azureSubscription: '$(azureConnection)'
              appType: 'webAppLinux'
              appName: '$(webProdName)'
              package: '$(Pipeline.Workspace)/front_prod_unpack/front-prod-with-env.zip'

          # Deploy API PROD
          - task: AzureWebApp@1
            displayName: 'Deploy API to $(apiProdName)'
            inputs:
              azureSubscription: '$(azureConnection)'
              appType: 'webAppLinux'
              appName: '$(apiProdName)'
              package: '$(Pipeline.Workspace)/back/backend.zip'

          # Seed PROD (opcional)
          - script: |
              set -e
              echo "Seeding PROD..."
              curl -X POST "$(apiBaseUrlPROD)admin/seed" -H "X-Seed-Token: $(seedTokenPROD)"
            displayName: 'Seed PROD DB'
            condition: and(succeeded(), ne(variables['seedTokenPROD'], ''))

          # Smoke tests PROD (API + FRONT)
          - script: |
              set -e
              echo "Waiting API to be ready..."
              for i in {1..20}; do
                curl -fsS "$(apiBaseUrlPROD)readyz" && break || sleep 5
              done
              curl -fsS "$(apiBaseUrlPROD)healthz"
              echo "Checking FRONT (index)..."
              for i in {1..20}; do
                curl -fsS "$(webBaseUrlPROD)" && break || sleep 5
              done
            displayName: 'Smoke tests PROD'
            condition: and(succeeded(), eq(variables['runSmokeTests'], 'true'))
