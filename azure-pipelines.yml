trigger:
- main

pool:
  vmImage: 'ubuntu-latest'

variables:
  node_version: '20.x'
  python_version: '3.12'
  azureConnection: 'azure-tp05-connection'

  # Nombres de las Web Apps (las tomás de variables de UI)
  apiQaName:   '$(apiAppNameQA)'
  apiProdName: '$(apiAppNamePROD)'
  webQaName:   '$(webAppNameQA)'
  webProdName: '$(webAppNamePROD)'

  # Toggle de pruebas de humo
  runSmokeTests: 'false'   # poné 'true' si querés ejecutarlas

  # ------- TP08: Docker Hub -------
  dockerHubServiceConnection: 'dockerhub-connection'   # Service Connection en Azure DevOps
  dockerHubNamespace: 'yagogandara'                    # Tu usuario Docker Hub
  apiImageName: 'todos-api'
  webImageName: 'todos-web'
  imageTag: '$(Build.BuildId)'                         # Tag de imagen = número de build

stages:
# ==================== BUILD & ANALYZE ====================
- stage: Build
  displayName: Build, Test, Coverage, Sonar & Docker
  jobs:
  - job: build_and_analyze
    displayName: Front + Back + Coverage + Sonar + Docker
    steps:
    - checkout: self
      fetchDepth: 0

    # ---------- Node + Python toolchains ----------
    - task: NodeTool@0
      inputs:
        versionSpec: '$(node_version)'

    - task: UsePythonVersion@0
      inputs:
        versionSpec: '$(python_version)'
        architecture: 'x64'

    # ---------- SonarCloud: Prepare (usa sonar-project.properties) ----------
    - task: SonarCloudPrepare@2
      displayName: 'Prepare SonarCloud analysis'
      inputs:
        SonarCloud: 'SonarCloud'          # service connection
        organization: 'chinogandara'
        scannerMode: 'CLI'
        configMode: 'file'
        configFile: 'sonar-project.properties'
        extraProperties: |
          sonar.python.coverage.reportPaths=backend/coverage.xml

          sonar.javascript.lcov.reportPaths=frontend/coverage/lcov.info

          sonar.exclusions=**/node_modules/**,**/dist/**,frontend/cypress/**,**/*.spec.ts

          sonar.javascript.file.suffixes=.js
          sonar.typescript.file.suffixes=.ts,.tsx,.cts,.mts

    # ---------- FRONTEND: install + unit tests (coverage) ----------
    - script: |
        set -e
        cd frontend
        npm ci --no-audit --no-fund || npm i --no-audit --no-fund --legacy-peer-deps
      displayName: 'Frontend - npm ci'

    - script: |
        set -e
        cd frontend
        npm run test:ci
      displayName: 'Frontend - unit tests with coverage'

    - task: PublishCodeCoverageResults@1
      displayName: 'Publish frontend code coverage'
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: 'frontend/coverage/cobertura.xml'
        reportDirectory: 'frontend/coverage'

    # ---------- CYPRESS E2E -------------
    - script: |
        set -e
        cd frontend
        npm run e2e
      displayName: 'Frontend - Cypress E2E'

    # ---------- BACKEND: deps + lint + tests (coverage + integración) ----------
    - script: |
        set -e
        cd backend
        python -m pip install --upgrade pip
        pip install -r requirements.txt
      displayName: 'Backend - install deps'

    - script: |
        set -e
        cd backend
        flake8 app
      displayName: 'Backend - flake8'

    - script: |
        set -e
        cd backend
        pytest --cov=app \
               --cov-report=xml:coverage.xml \
               --cov-report=html \
               --junitxml=TEST-backend.xml
      displayName: 'Backend - pytest (unit + integration + coverage)'

    - task: PublishTestResults@2
      displayName: 'Publish backend unit test results'
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: 'backend/TEST-backend.xml'
        failTaskOnFailedTests: true

    - task: PublishCodeCoverageResults@1
      displayName: 'Publish backend code coverage'
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: 'backend/coverage.xml'
        reportDirectory: 'backend/htmlcov'
        failIfCoverageEmpty: true

    # ---------- SonarCloud: Run analysis & publish Quality Gate ----------
    - task: SonarCloudAnalyze@2
      displayName: 'Run SonarCloud analysis'

    - task: SonarCloudPublish@2
      displayName: 'Publish SonarCloud quality gate'
      inputs:
        pollingTimeoutSec: '300'

    # ---------- DOCKER: Build & Push images to Docker Hub ----------
    - task: Docker@2
      displayName: 'Build & Push API image'
      inputs:
        containerRegistry: '$(dockerHubServiceConnection)'
        repository: '$(dockerHubNamespace)/$(apiImageName)'
        command: 'buildAndPush'
        Dockerfile: 'backend/Dockerfile'
        buildContext: 'backend'
        tags: |
          $(imageTag)
          latest

    - task: Docker@2
      displayName: 'Build & Push Web image'
      inputs:
        containerRegistry: '$(dockerHubServiceConnection)'
        repository: '$(dockerHubNamespace)/$(webImageName)'
        command: 'buildAndPush'
        Dockerfile: 'frontend/Dockerfile.prod'
        buildContext: 'frontend'
        tags: |
          $(imageTag)
          latest

# ==================== DEPLOY QA (CONTAINERS) ====================
- stage: DeployQA
  displayName: Deploy to QA (containers)
  dependsOn: Build
  condition: succeeded()
  jobs:
  - deployment: QaDeploy
    displayName: Deploy Front & API to QA
    environment: 'QA'
    strategy:
      runOnce:
        deploy:
          steps:
          # Deploy API QA como contenedor
          - task: AzureWebAppContainer@1
            displayName: 'Deploy API container to $(apiQaName)'
            inputs:
              azureSubscription: '$(azureConnection)'
              appName: '$(apiQaName)'
              containers: |
                $(dockerHubNamespace)/$(apiImageName):$(imageTag)
              appSettings: |
                -APP_ENV qa

          # Deploy WEB QA como contenedor
          - task: AzureWebAppContainer@1
            displayName: 'Deploy Web container to $(webQaName)'
            inputs:
              azureSubscription: '$(azureConnection)'
              appName: '$(webQaName)'
              containers: |
                $(dockerHubNamespace)/$(webImageName):$(imageTag)
              appSettings: |
                -APP_ENV qa
                -API_BASE_URL $(apiBaseUrlQA)

          # Smoke tests QA (API + FRONT)
          - script: |
              set -e
              echo "Waiting API to be ready..."
              for i in {1..20}; do
                curl -fsS "$(apiBaseUrlQA)readyz" && break || sleep 5
              done
              curl -fsS "$(apiBaseUrlQA)healthz"
              echo "Checking FRONT (index)..."
              for i in {1..20}; do
                curl -fsS "$(webBaseUrlQA)" && break || sleep 5
              done
            displayName: 'Smoke tests QA'
            condition: and(succeeded(), eq(variables['runSmokeTests'], 'true'))

# ==================== DEPLOY PROD (CONTAINERS) ====================
- stage: DeployPROD
  displayName: Deploy to PROD (containers)
  dependsOn: DeployQA
  condition: succeeded()
  jobs:
  - deployment: ProdDeploy
    displayName: Deploy Front & API to PROD
    environment: 'PROD'   # acá configurás aprobación manual
    strategy:
      runOnce:
        deploy:
          steps:
          # Deploy API PROD como contenedor
          - task: AzureWebAppContainer@1
            displayName: 'Deploy API container to $(apiProdName)'
            inputs:
              azureSubscription: '$(azureConnection)'
              appName: '$(apiProdName)'
              containers: |
                $(dockerHubNamespace)/$(apiImageName):$(imageTag)
              appSettings: |
                -APP_ENV prod

          # Deploy WEB PROD como contenedor
          - task: AzureWebAppContainer@1
            displayName: 'Deploy Web container to $(webProdName)'
            inputs:
              azureSubscription: '$(azureConnection)'
              appName: '$(webProdName)'
              containers: |
                $(dockerHubNamespace)/$(webImageName):$(imageTag)
              appSettings: |
                -APP_ENV prod
                -API_BASE_URL $(apiBaseUrlPROD)

          # Smoke tests PROD (API + FRONT)
          - script: |
              set -e
              echo "Waiting API to be ready..."
              for i in {1..20}; do
                curl -fsS "$(apiBaseUrlPROD)readyz" && break || sleep 5
              done
              curl -fsS "$(apiBaseUrlPROD)healthz"
              echo "Checking FRONT (index)..."
              for i in {1..20}; do
                curl -fsS "$(webBaseUrlPROD)" && break || sleep 5
              done
            displayName: 'Smoke tests PROD'
            condition: and(succeeded(), eq(variables['runSmokeTests'], 'true'))
